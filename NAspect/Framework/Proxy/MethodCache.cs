// *
// * Copyright (C) 2005 Roger Johansson : http://www.puzzleframework.com
// *
// * This library is free software; you can redistribute it and/or modify it
// * under the terms of the GNU Lesser General Public License 2.1 or later, as
// * published by the Free Software Foundation. See the included license.txt
// * or http://www.gnu.org/copyleft/lesser.html for details.
// *
// *

using System;
using System.Collections;
using System.Diagnostics;
using System.Reflection;

namespace Puzzle.NAspect.Framework
{
    /// <summary>
    /// Cache used by the emitter to store various lookup values.
    /// There is actually not a single person alive that knows exactly what these lists hold.
    /// It has been long forgotten by the ancients.
    /// </summary>
    public class MethodCache
    {
        /// <summary>
        /// Contains an arraylist of affected mixins for a proxytype
        /// </summary>
        public static Hashtable mixinsLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of affected aspects for a proxytype
        /// </summary>
        public static Hashtable aspectsLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of affected methods for a proxytype
        /// </summary>
        public static Hashtable methodsLookup = new Hashtable();

        /// <summary>
        /// Contains the base methodinfo for each methodid (wrappername)
        /// </summary>
        public static Hashtable methodLookup = new Hashtable();

        /// <summary>
        /// Contains the wrapper methodinfo for each methodid(wrappername)
        /// </summary>
        public static Hashtable wrapperMethodLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of interceptors for each methodId (wrappername)
        /// </summary>
        public static Hashtable methodInterceptorsLookup = new Hashtable();

        /// <summary>
        /// Gets the interceptors associated with a unique methodId
        /// </summary>
        /// <param name="methodId">unique methodId generated by the proxy emitter.</param>
        /// <returns>List of IInterceptors and BeforeDelegate , AroundDelegate and AfterDelegates</returns>
        [DebuggerStepThrough()]
        public static IList GetInterceptors(string methodId)
        {
            if (methodId == null)
                throw new NullReferenceException("Method may not be null");


            if (methodInterceptorsLookup.Contains(methodId))
            {
                IList methodinterceptors = methodInterceptorsLookup[methodId] as IList;
                return methodinterceptors;
            }

            throw new Exception("Unknown method");
        }

        //used by the explicit iface proyfier
        /// <summary>
        /// 
        /// </summary>
        public static MethodInfo GetMethodMethodInfo = typeof (MethodCache).GetMethod("GetMethod");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="methodId"></param>
        /// <returns></returns>
        [DebuggerStepThrough()]
        public static MethodBase GetMethod(string methodId)
        {
            return (MethodBase) methodLookup[methodId];
        }



        private static Hashtable callInfoMapper = new Hashtable();
        private static ArrayList callInfos = new ArrayList();
        internal static CallInfo GetCallInfo(int methodIndex)
        {
            return (CallInfo)callInfos[methodIndex];
        }

        internal static CallInfo GetCallInfo(string methodId)
        {
            return (CallInfo)callInfoMapper[methodId];
        }
        
        internal static int AddCallInfo(CallInfo callInfo, string methodId)
        {
            int res = 0;
            lock(callInfos.SyncRoot)
            {
                res = callInfos.Add(callInfo);
                callInfoMapper[methodId] = callInfo;
            }
            return res;
        }
    }
}